#!/usr/bin/env node

import dotenv from 'dotenv';
import mongoose from 'mongoose';
import connectDB from '../config/database.js';
import performanceOptimizer from '../utils/performanceOptimizer.js';
import logger from '../utils/logger.js';

// Load environment variables
dotenv.config();

async function runPerformanceAudit() {
  try {
    console.log('üîç Starting Performance Audit...\n');
    
    // Connect to database
    await connectDB();
    console.log('‚úÖ Connected to database\n');
    
    // Generate comprehensive performance report
    const report = await performanceOptimizer.generatePerformanceReport();
    
    // Display results
    console.log('üìä PERFORMANCE AUDIT REPORT');
    console.log('=' .repeat(50));
    console.log(`Timestamp: ${report.timestamp.toISOString()}`);
    console.log(`Performance Score: ${report.summary.performanceScore}/100`);
    console.log(`Critical Issues: ${report.summary.criticalIssues}`);
    console.log(`Total Recommendations: ${report.summary.recommendations}\n`);
    
    // Database Analysis
    console.log('üóÑÔ∏è  DATABASE ANALYSIS');
    console.log('-'.repeat(30));
    
    // Index Analysis
    console.log('\nüìã Current Indexes:');
    for (const [collection, data] of Object.entries(report.database.indexes)) {
      if (data.error) {
        console.log(`  ‚ùå ${collection}: ${data.error}`);
      } else {
        console.log(`  üìÅ ${collection}: ${data.indexes.length} indexes, ${data.stats.count} documents`);
        console.log(`     Storage: ${Math.round(data.stats.storageSize / 1024 / 1024 * 100) / 100}MB`);
        console.log(`     Index Size: ${Math.round(data.stats.totalIndexSize / 1024 / 1024 * 100) / 100}MB`);
      }
    }
    
    // Missing Indexes
    if (report.database.missingIndexes.length > 0) {
      console.log('\n‚ö†Ô∏è  Missing Indexes:');
      report.database.missingIndexes.forEach((idx, i) => {
        const priority = idx.priority === 'high' ? 'üî¥' : idx.priority === 'medium' ? 'üü°' : 'üü¢';
        console.log(`  ${priority} ${idx.collection}: ${Object.keys(idx.index).join(', ')}`);
        console.log(`     Reason: ${idx.reason}`);
      });
    } else {
      console.log('\n‚úÖ All recommended indexes are present');
    }
    
    // Query Performance
    console.log('\n‚ö° Query Performance:');
    const queryPerf = report.database.queryPerformance;
    console.log(`  Total Queries: ${queryPerf.totalQueries}`);
    console.log(`  Slow Queries: ${queryPerf.slowQueries}`);
    console.log(`  Average Execution Time: ${queryPerf.averageExecutionTime}ms`);
    
    if (Object.keys(queryPerf.queryBreakdown).length > 0) {
      console.log('\n  Query Breakdown:');
      Object.entries(queryPerf.queryBreakdown)
        .sort(([,a], [,b]) => b.avgTime - a.avgTime)
        .slice(0, 5)
        .forEach(([query, stats]) => {
          const status = stats.avgTime > 100 ? 'üî¥' : stats.avgTime > 50 ? 'üü°' : 'üü¢';
          console.log(`    ${status} ${query}: ${stats.avgTime}ms avg (${stats.count} calls)`);
        });
    }
    
    // Request Deduplication
    console.log('\nüîÑ REQUEST DEDUPLICATION');
    console.log('-'.repeat(30));
    if (report.requests.issues.length > 0) {
      console.log(`‚ö†Ô∏è  Found ${report.requests.issues.length} potential duplicate request issues:`);
      report.requests.issues.forEach(issue => {
        console.log(`  ‚Ä¢ ${issue.queryKey}: ${issue.instances} instances within ${issue.timeDifference}ms`);
      });
      
      console.log('\nüí° Recommendations:');
      report.requests.recommendations.forEach(rec => {
        console.log(`  ‚Ä¢ ${rec}`);
      });
    } else {
      console.log('‚úÖ No duplicate request issues detected');
    }
    
    // Image Optimization
    console.log('\nüñºÔ∏è  IMAGE OPTIMIZATION');
    console.log('-'.repeat(30));
    if (report.images.recommendations.length > 0) {
      report.images.recommendations.forEach(rec => {
        console.log(`üìã ${rec.type.toUpperCase()}:`);
        if (rec.issue) {
          console.log(`  Issue: ${rec.issue}`);
        }
        console.log('  Suggestions:');
        rec.suggestions.forEach(suggestion => {
          console.log(`    ‚Ä¢ ${suggestion}`);
        });
        console.log('');
      });
    }
    
    // Auto-optimization prompt
    console.log('\nüöÄ AUTO-OPTIMIZATION');
    console.log('-'.repeat(30));
    
    const highPriorityIndexes = report.database.missingIndexes.filter(idx => idx.priority === 'high');
    if (highPriorityIndexes.length > 0) {
      console.log(`Found ${highPriorityIndexes.length} high-priority missing indexes.`);
      
      // Check if --auto-fix flag is provided
      const autoFix = process.argv.includes('--auto-fix');
      
      if (autoFix) {
        console.log('üîß Auto-fixing enabled. Creating missing indexes...');
        const results = await performanceOptimizer.autoOptimize({ createIndexes: true });
        
        console.log(`‚úÖ Created ${results.indexesCreated.length} indexes`);
        results.indexesCreated.forEach(result => {
          console.log(`  ‚Ä¢ ${result.collection}: ${Object.keys(result.index).join(', ')}`);
        });
        
        if (results.errors.length > 0) {
          console.log(`‚ùå Errors: ${results.errors.length}`);
          results.errors.forEach(error => console.log(`  ‚Ä¢ ${error}`));
        }
      } else {
        console.log('üí° Run with --auto-fix to automatically create missing indexes');
        console.log('   Example: npm run audit:performance -- --auto-fix');
      }
    } else {
      console.log('‚úÖ No high-priority optimizations needed');
    }
    
    // Summary and Score Interpretation
    console.log('\nüìà PERFORMANCE SCORE BREAKDOWN');
    console.log('-'.repeat(30));
    const score = report.summary.performanceScore;
    let scoreInterpretation = '';
    let scoreEmoji = '';
    
    if (score >= 90) {
      scoreEmoji = 'üü¢';
      scoreInterpretation = 'Excellent - Your API is well optimized';
    } else if (score >= 75) {
      scoreEmoji = 'üü°';
      scoreInterpretation = 'Good - Minor optimizations recommended';
    } else if (score >= 60) {
      scoreEmoji = 'üü†';
      scoreInterpretation = 'Fair - Several optimizations needed';
    } else {
      scoreEmoji = 'üî¥';
      scoreInterpretation = 'Poor - Significant optimizations required';
    }
    
    console.log(`${scoreEmoji} Score: ${score}/100 - ${scoreInterpretation}`);
    
    // Recommendations summary
    if (report.summary.recommendations > 0) {
      console.log('\nüéØ NEXT STEPS:');
      console.log('1. Create missing high-priority database indexes');
      console.log('2. Implement request deduplication middleware');
      console.log('3. Optimize image serving and compression');
      console.log('4. Monitor query performance regularly');
      console.log('5. Consider implementing caching layer');
    }
    
    console.log('\n‚úÖ Performance audit completed!');
    
    // Save detailed report to file
    const fs = await import('fs/promises');
    const reportPath = `performance-audit-${Date.now()}.json`;
    await fs.writeFile(reportPath, JSON.stringify(report, null, 2));
    console.log(`üìÑ Detailed report saved to: ${reportPath}`);
    
  } catch (error) {
    console.error('‚ùå Performance audit failed:', error);
    logger.error('Performance audit error:', error);
    process.exit(1);
  } finally {
    await mongoose.connection.close();
    console.log('\nüîå Database connection closed');
  }
}

// Handle command line arguments
const args = process.argv.slice(2);
const showHelp = args.includes('--help') || args.includes('-h');

if (showHelp) {
  console.log(`
üîç Performance Audit Tool

Usage: node performanceAudit.js [options]

Options:
  --auto-fix    Automatically create missing high-priority indexes
  --help, -h    Show this help message

Examples:
  node performanceAudit.js                    # Run audit only
  node performanceAudit.js --auto-fix         # Run audit and auto-fix issues
  
This tool analyzes your API's performance and provides recommendations for:
‚Ä¢ Database indexing optimization
‚Ä¢ Query performance analysis  
‚Ä¢ Request deduplication issues
‚Ä¢ Image serving optimization
‚Ä¢ Overall performance scoring
`);
  process.exit(0);
}

// Run the audit
runPerformanceAudit();